{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nrightMotor = Motor(Ports.PORT1, False)\nleftMotor = Motor(Ports.PORT6, True)\ngyro_3 = Gyro(Ports.PORT3)\ntresmotores = Motor(Ports.PORT5, False)\nleftFly = Motor(Ports.PORT2, False)\nrightFly = Motor(Ports.PORT4, True)\ncontroller = Controller()\nrollers = Motor(Ports.PORT8, False)\npneumatic_7 = Pneumatic(Ports.PORT7)\noptical_9 = Optical(Ports.PORT9)\ntouchled_10 = Touchled(Ports.PORT10)\n\n\n\n# generating and setting random seed\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    systemTime = brain.timer.system() * 100\n    urandom.seed(int(xaxis + yaxis + zaxis + systemTime)) \n    \n# Initialize random seed \ninitializeRandomSeed()\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n# \tAuthor:       VEX\n# \tCreated:\n# \tDescription:  VEXcode IQ Python Project\n# \n# ------------------------------------------\n\n# Library imports\nimport math\nfrom vex import *\n\n# Begin project code\nclass PIDController:\n    def __init__(self,kp,ki=0.0, kd = 0.0):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.prev_error = 0\n        self.integral = 0\n\n    def compute(self,setpoint,actual_value, dt = 1):\n        # calculate error\n\n        error = setpoint - actual_value\n\n        # propotional term\n        proportional = self.kp * error\n\n        #integral term (accumalate error over time)\n        self.integral += error * dt\n        integral = self.ki * self.integral\n\n        #derivate term (rate of error change)\n        derivative = self.kd * (error - self.prev_error) / dt\n        self.prev_error = error\n\n        # PID output\n        output = proportional + integral + derivative\n\n        return output\n\n# ODOMETRY CLASS\nclass Odometry:\n    def __init__(self,robot):\n        self.robot = robot\n        self.x_pos = 0.0\n        self.y_pos = 0.0\n        self.head = 0.0\n\n    def update_position(self):\n\n        # get motor position (ticks)\n        left_ticks = self.robot.leftMotor.position(DEGREES)\n        right_ticks = self.robot.rightMotor.position(DEGREES)\n        strafe_ticks = self.robot.strafeMotor.position(DEGREES)\n\n\n        #convert our ticks to distance (adjusted with our gear ratio)\n        left_distance = left_ticks * self.robot.DISTANCE_PER_TICK\n        right_distance = right_ticks * self.robot.DISTANCE_PER_TICK\n        strafe_distance = strafe_ticks * self.robot.SDISTANCE_PER_TICK # strafe distance per tick\n\n        # forward position\n        forward_d = (left_distance + right_distance)/2\n\n        # calculate our heading\n        current_head = self.robot.gyro_3.rotation(DEGREES)\n        self.head = current_head\n\n\n        # calculate the new x and y position and heading\n        delta_x = forward_d * math.cos(math.radians(self.head)) + strafe_distance * math.sin(math.radians(self.head))\n        delta_y = forward_d * math.sin(math.radians(self.head)) - strafe_distance * math.cos(math.radians(self.head))\n        self.x_pos += delta_x\n        self.y_pos += delta_y\n\n\n        \n        self.robot.leftMotor.set_position(0,DEGREES)\n        self.robot.rightMotor.set_position(0,DEGREES)\n        self.robot.strafeMotor.set_position(0,DEGREES)\n        \n\n\n\nclass Intake:\n    toggle=False\n    def __init__(self):\n        self.intake = Motor(Ports.PORT8, True)\n        self.speed = 0\n\n    def start_intake(self,speed_pct):\n        self.speed = speed_pct\n        self.intake.set_velocity(speed_pct,RPM)\n        self.intake.spin(FORWARD)\n\n    def stop_intake(self):\n        self.intake.stop()\n\n    def reverse_intake(self,speed_pct):\n        self.speed = speed_pct\n        self.intake.set_velocity(speed_pct,RPM)\n        self.intake.spin(REVERSE)\n\n    def set_speed(self,new_speed):\n        self.speed = new_speed\n        self.intake.set_velocity(self.speed,RPM)\n        self.intake.spin(FORWARD)\n\n    def get_speed(self):\n        return self.speed\n    \n\n        \n\n    \n\nclass Flywheel:\n    GEAR_RATIO = 20 # 20:1 gear ratio(flywheel spins 20 times for 1 motor rotation)\n\n    def __init__(self):\n        self.leftFly = Motor(Ports.PORT2, True)\n        self.rightFly = Motor(Ports.PORT4, False)\n        self.leftFly.set_stopping(COAST)\n        self.rightFly.set_stopping(COAST)\n        self.vel = 0 # Flywheel speed percantage\n\n    def start_wheel(self,speed):\n        '''Start the flywheel at a given speed'''\n        self.vel = speed\n\n        #spin the motor at the desired speed percentage\n        #since the flywheel spins 20 times faster, we control the motor accordingly\n        self.leftFly.set_velocity(speed,RPM)\n        self.rightFly.set_velocity(speed,RPM)\n\n        self.leftFly.spin(FORWARD)\n        self.rightFly.spin(FORWARD)\n\n    def stop_flywheel(self):\n        '''stops the flywheel motor'''\n        self.leftFly.stop()\n        self.rightFly.stop()\n    \n    def set_speed(self,new_speed):\n        '''set a new speed to flywheel motors'''\n        self.vel = new_speed\n        self.leftFly.set_velocity(new_speed,RPM)\n        self.rightFly.set_velocity(new_speed,RPM)\n    \n    def get_speed(self):\n\n        return self.vel\n\n    def calculate_flywheel_speed(self):\n        motorrpm = self.leftFly.velocity(RPM)\n        motorrmp2 = self.rightFly.velocity(RPM)\n        rpm = (motorrpm + motorrmp2)/2\n        flywheelRPM = rpm * self.GEAR_RATIO\n        return flywheelRPM\n    def flywheel_rpm(self):\n        motorrpm = self.leftFly.velocity(RPM)\n        motorrmp2 = self.rightFly.velocity(RPM)\n        rpm = (motorrpm + motorrmp2)/2\n        return rpm \n\nclass Robot:\n    # constants\n    WHEEL_DIAMETER = 2.5 # INCHES\n    ENCODER_TICKS_PER_REV = 960 # TICKS PER FULL REVOLUTION OF VEX IQ MOTORS\n    GEAR_RATIO = 0.5 # 1:2 GEAR RATIO FOR SPEED\n    WHEEL_CIRCUMFERENCE = math.pi * WHEEL_DIAMETER\n    DISTANCE_PER_TICK = WHEEL_CIRCUMFERENCE / (ENCODER_TICKS_PER_REV * GEAR_RATIO)\n    TRACK_WIDTH = 11\n    SDISTANCE_PER_TICK = WHEEL_CIRCUMFERENCE / ENCODER_TICKS_PER_REV\n\n    def __init__(self):\n        self.rightMotor = Motor(Ports.PORT1, True)\n        self.leftMotor = Motor(Ports.PORT6, False)\n        self.gyro_3 = Gyro(Ports.PORT3)\n        self.strafeMotor = Motor(Ports.PORT5, True)\n        self.strafeMotor.set_velocity(120,RPM)\n        self.flywheel = Flywheel()\n        self.intake  = Intake()\n\n        brain.screen.print(\"calibration start\")\n        brain.screen.next_row()\n        self.gyro_3.calibrate(GyroCalibrationType.NORMAL)\n        wait(2,SECONDS)\n        brain.screen.next_row()\n        brain.screen.print(\"calibration ended\")\n        self.heading_pid = PIDController(kp=0.5,kd=0.1)\n        self.turn_pid = PIDController(kp=0.8,kd=0.1)\n\n\n        self.odometry = Odometry(self)\n\n    def set_drive_speed(self,speedL,speedR):\n        self.leftMotor.set_velocity(speedL,PERCENT)\n        self.rightMotor.set_velocity(speedR,PERCENT)\n\n    def driveF(self):\n        self.leftMotor.spin(FORWARD)\n        self.rightMotor.spin(FORWARD)\n    \n    def driveFj(self,sec):\n        self.leftMotor.spin(FORWARD)\n        self.rightMotor.spin(FORWARD)\n        self.strafeMotor.spin(FORWARD)\n        wait(sec,SECONDS)\n        self.leftMotor.stop()\n        self.rightMotor.stop()\n        self.strafeMotor.stop()\n\n    def driveRj(self,sec):\n        self.leftMotor.spin(REVERSE)\n        self.rightMotor.spin(REVERSE)\n        self.strafeMotor.spin(REVERSE)\n        wait(sec,SECONDS)\n        self.leftMotor.stop()\n        self.rightMotor.stop()\n        self.strafeMotor.stop()\n    def shoot_ball(self):\n        pneumatic_7.retract(CYLINDER1)\n        pneumatic_7.retract(CYLINDER2)\n        wait(0.4,SECONDS)\n        pneumatic_7.extend(CYLINDER1)\n        pneumatic_7.extend(CYLINDER2)\n        \n\n    \n\n#-----------------------------------------------------------------------------------------\n#                                  FLYWHEEL IN ROBOT METHODS\n#-----------------------------------------------------------------------------------------\n    def start_flywheel(self,speed):\n        self.flywheel.start_wheel(speed)\n    def stop_flywheel(self):\n        self.flywheel.stop_flywheel()\n    def set_flywheel_speed(self,new_speed):\n        self.flywheel.set_speed(new_speed)\n    def get_flywheel_speed(self):\n        return self.flywheel.get_speed()\n    def get_flywheel_rpm(self):\n        return self.flywheel.calculate_flywheel_speed()\n    def flywheely_rpm(self):\n        return self.flywheel.flywheel_rpm()\n\n#-----------------------------------------------------------------------------------------\n#                                  INTAKE IN ROBOT METHODS\n#-----------------------------------------------------------------------------------------\n    def start_intake(self,speed_pct):\n        self.intake.start_intake(speed_pct)\n    \n    def stop_intake(self):\n        self.intake.stop_intake()\n    \n    def reverse_intake(self, speed_pct):\n        self.intake.reverse_intake(speed_pct)\n    def set_intake_speed(self,speed_pct):\n        self.intake.set_speed(speed_pct)\n    def get_intake_speed(self):\n        return self.intake.get_speed()\n\nclass VEXController:\n    def __init__(self,controller,robot):\n        self.controller = controller\n        self.robot = robot\n \n        self.flywheel_active = True\n        self.rollers_active = False\n        self.pneumatics_active = False\n        self.robot.start_flywheel(120)\n        self.rollers_stay = False\n        pneumatic_7.extend(CYLINDER1)\n        pneumatic_7.extend(CYLINDER2)\n    \n    def standard_drive(self):\n        self.robot.start_flywheel(0)\n        #while not self.controller.buttonEDown.pressing() and not self.controller.buttonFDown.pressing():\n        while True:\n            # forward/backward controller by the left analog stick Axis A\n            forward_speed = self.controller.axisA.position()\n\n            #strafe_speed = self.controller.axisB.position()\n\n            turn_speed = -self.controller.axisC.position() * 10\n\n            left_motor_speed = forward_speed + turn_speed\n            right_motor_speed = forward_speed - turn_speed\n\n            self.robot.set_drive_speed(left_motor_speed,right_motor_speed)\n            tresmotores.set_velocity(forward_speed)\n            tresmotores.spin(FORWARD)\n            \n            #self.robot.strafeMotor.set_velocity(strafe_speed,PERCENT)\n\n            self.robot.driveF()\n            #self.robot.strafeMotor.spin(FORWARD)\n            \n            \n           \n            if self.controller.buttonLUp.pressing():\n                self.robot.set_flywheel_speed(120)\n            if self.controller.buttonLDown.pressing():\n                self.robot.set_flywheel_speed(65)\n            '''\n            if self.controller.buttonEUp.pressing():\n                pneumatic_7.retract(CYLINDER1)\n                pneumatic_7.retract(CYLINDER2)\n                #0.4\n                wait(0.4,SECONDS)\n                pneumatic_7.extend(CYLINDER1)\n                pneumatic_7.extend(CYLINDER2)\n                self.robot.start_intake(120)\n                wait(0.75,SECONDS)\n                self.robot.stop_intake()\n            '''\n\n            \n            if self.controller.buttonL3.pressing():\n                pneumatic_7.pump_on()\n                touchled_10.set_brightness(100)\n                touchled_10.set_color(Color.GREEN)\n            \n            if self.controller.buttonR3.pressing():\n                pneumatic_7.pump_off()\n                touchled_10.set_brightness(100)\n                touchled_10.set_color(Color.RED)\n            \n            if self.controller.buttonFUp.pressing():\n                self.robot.set_flywheel_speed(0)\n            \n           \n            brain.screen.print(self.robot.get_flywheel_speed())\n            wait(10,MSEC)\n            brain.screen.clear_screen()\n    def shoot(self):\n        #while not self.controller.buttonEDown.pressing() and not self.controller.buttonFDown.pressing():\n        while True:\n            if self.controller.buttonEUp.pressing():\n                pneumatic_7.retract(CYLINDER1)\n                pneumatic_7.retract(CYLINDER2)\n                #0.4\n                wait(0.4,SECONDS)\n                pneumatic_7.extend(CYLINDER1)\n                pneumatic_7.extend(CYLINDER2)\n                self.robot.start_intake(120)\n                wait(0.75,SECONDS)\n                self.robot.stop_intake()\n             \n             # Roller Activation using R buttons\n            if self.controller.buttonRUp.pressing():\n                self.robot.start_intake(120)\n                \n            elif self.controller.buttonRDown.pressing():\n                self.robot.reverse_intake(120)\n            \n            elif not self.controller.buttonRDown.pressing() and  not self.controller.buttonRUp.pressing():\n                self.robot.stop_intake()\n            else:\n                pass\n        wait(20,MSEC)\n    def auto(self):\n        while True:\n            while not self.controller.buttonEDown.pressing() and not self.controller.buttonFDown.pressing():\n                touchled_10.set_color(Color.PURPLE)\n            self.robot.start_flywheel(85)\n            self.robot.start_intake(120)\n            while True:\n                self.robot.set_drive_speed(100,100)\n                touchled_10.set_color(Color.BLUE)\n                self.robot.driveRj(0.25)\n                wait(0.3,SECONDS)\n                self.robot.driveFj(0.55)\n                if optical_9.is_near_object():\n                    \n                    self.robot.shoot_ball()\n                    \n                else:\n                    pass\n\n                wait(0.5,SECONDS)\ntouchled_10.set_brightness(100) \ntouchled_10.set_color(Color.GREEN)\n\nbobby = Robot()\nJillur = VEXController(controller,bobby)\nws1 = Thread(Jillur.shoot)\n#ws2 = Thread(Jillur.auto)\nJillur.standard_drive()\n\n","textLanguage":"python","robotConfig":[{"port":[1],"name":"rightMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"leftMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[3],"name":"gyro_3","customName":false,"deviceType":"Gyro","deviceClass":"gyro","setting":{},"triportSourcePort":22},{"port":[5],"name":"tresmotores","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[2],"name":"leftFly","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[4],"name":"rightFly","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[],"name":"controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[8],"name":"rollers","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[7],"name":"pneumatic_7","customName":false,"deviceType":"Pneumatic","deviceClass":"pneumatic","setting":{"cylinder1":"cylinder1","cylinder2":"cylinder2","cylinder1_reversed":"false","cylinder2_reversed":"false","cylinder3":"","cylinder4":""},"triportSourcePort":22},{"port":[9],"name":"optical_9","customName":false,"deviceType":"Optical","deviceClass":"optical","setting":{},"triportSourcePort":22},{"port":[10],"name":"touchled_10","customName":false,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false}